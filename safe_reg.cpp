
#include <cstddef>
#include <cstdint>
#include <cassert>
#include <iostream>
#include <type_traits>

// Begin Autogenerated Code =========================

// STM32F4 family from ST Microelectronics. Based on a Cortex M4F core.
namespace STM32F4xx {

// Reset and Clock Control peripheral for STM32F4xx family.
class RCC {
public:
  enum Peripheral {
    PERIPHERAL_BASE_ADDRESS = 0x40023800
  };

  // RCC clock control register
  class CR {
  public:
    enum Register {
      REGISTER_OFFSET = 0x00000000,
      REGISTER_SIZE = 4,
    };

    enum Offsets {
      OFFSET_HSION     = 0,
      OFFSET_HSIRDY    = 1,
      OFFSET_HSITRIM   = 3,
      OFFSET_HSICAL    = 8,
      OFFSET_HSEON     = 16,
      OFFSET_HSERDY    = 17,
      OFFSET_HSEBYP    = 18,
      OFFSET_CSSON     = 19,
      OFFSET_PLLON     = 24,
      OFFSET_PLLRDY    = 25,
      OFFSET_PLLI2SON  = 26,
      OFFSET_PLLI2SRDY = 27
    };

    enum Masks {
      MASK_HSION     = 0x00000001,
      MASK_HSIRDY    = 0x00000002,
      MASK_HSITRIM   = 0x000000F8,
      MASK_HSICAL    = 0x0000FF00,
      MASK_HSEON     = 0x00010000,
      MASK_HSERDY    = 0x00020000,
      MASK_HSEBYP    = 0x00040000,
      MASK_CSSON     = 0x00080000,
      MASK_PLLON     = 0x01000000,
      MASK_PLLRDY    = 0x02000000,
      MASK_PLLI2SON  = 0x04000000,
      MASK_PLLI2SRDY = 0x08000000,
    };

    enum Resets {
      RESET_HSION     = 0x01,
      RESET_HSIRDY    = 0x01,
      RESET_HSITRIM   = 0x10,
      RESET_HSEON     = 0x00,
      RESET_HSERDY    = 0x00,
      RESET_HSEBYP    = 0x00,
      RESET_CSSON     = 0x00,
      RESET_PLLON     = 0x00,
      RESET_PLLRDY    = 0x00,
      RESET_PLLI2SON  = 0x00,
      RESET_PLLI2SRDY = 0x00
    };

    enum Limits {
      MIN_HSITRIM = 0x00,
      MAX_HSITRIM = 0x1F,
    };

    uint32_t read() const { return reg_; }
    volatile uint32_t& access() { return reg_; }
    void write(uint32_t value) { reg_ = value; }
    void reset() {
      reg_ = (reg_ & ~(MASK_HSION |
                       MASK_HSITRIM |
                       MASK_HSEON |
                       MASK_HSEBYP |
                       MASK_CSSON |
                       MASK_PLLON |
                       MASK_PLLI2SON)) |
             (RESET_HSION << OFFSET_HSION) |
             (RESET_HSITRIM << OFFSET_HSITRIM) |
             (RESET_HSEON << OFFSET_HSEON) |
             (RESET_HSEBYP << OFFSET_HSEBYP) |
             (RESET_CSSON << OFFSET_CSSON) |
             (RESET_PLLON << OFFSET_PLLON) |
             (RESET_PLLI2SON << OFFSET_PLLI2SON);
    }

    // HSION ---------------------

    enum class HSION {
      HSI_OFF = 0x00,
      HSI_ON = 0x01
    };

    HSION readHSION() const {
      return static_cast<HSION>((reg_ & MASK_HSION) >> OFFSET_HSION);
    }

    void writeHSION(HSION val) {
      reg_ = (reg_ & ~MASK_HSION) | (static_cast<uint32_t>(val) << OFFSET_HSION);
    }

    // HSIRDY ---------------------

    enum class HSIRDY {
      HSI_NOT_READY = 0x00,
      HSI_READY = 0x01
    };

    HSIRDY readHSIRDY() const {
      return static_cast<HSIRDY>((reg_ & MASK_HSIRDY) >> OFFSET_HSIRDY);
    }

    // HSITRIM ---------------------

    uint32_t readHSITRIM() const {
      return (reg_ & MASK_HSITRIM) >> OFFSET_HSITRIM;
    }

    void writeHSITRIM(uint32_t val) {
      assert((val <= MAX_HSITRIM));
      reg_ = (reg_ & ~MASK_HSITRIM) | (val << OFFSET_HSITRIM);
    }

    // HSICAL ---------------------

    uint32_t readHSICAL() const {
      return (reg_ & MASK_HSICAL) >> OFFSET_HSICAL;
    }

    // HSEON ----------------------

    enum class HSEON {
      HSE_OSC_OFF = 0x00,
      HSE_OSC_ON  = 0x01
    };

    HSEON readHSEON() const {
      return static_cast<HSEON>((reg_ & MASK_HSEON) >> OFFSET_HSEON);
    }

    void writeHSEON(HSEON val) {
      reg_ = (reg_ & ~MASK_HSEON) | (static_cast<uint32_t>(val) << OFFSET_HSEON);
    }

    // HSERDY ----------------------

    enum class HSERDY {
      HSE_NOT_READY = 0x00,
      HSE_READY = 0x01
    };

    HSERDY readHSERDY() const {
      return static_cast<HSERDY>((reg_ & MASK_HSERDY) >> OFFSET_HSERDY);
    }

    // HSEBYP ----------------------

    enum class HSEBYP {
      HSE_NOT_BYPASSED = 0x00,
      HSE_BYPASSED  = 0x01
    };

    HSEBYP readHSEBYP() const {
      return static_cast<HSEBYP>((reg_ & MASK_HSEBYP) >> OFFSET_HSEBYP);
    }

    void writeHSEBYP(HSEBYP val) {
      reg_ = (reg_ & ~MASK_HSEBYP) | (static_cast<uint32_t>(val) << OFFSET_HSEBYP);
    }

    // CSSON ----------------------

    enum class CSSON {
      CSS_OFF = 0x00,
      CSS_ON  = 0x01
    };

    CSSON readCSSON() const {
      return static_cast<CSSON>((reg_ & MASK_CSSON) >> OFFSET_CSSON);
    }

    void writeCSSON(CSSON val) {
      reg_ = (reg_ & ~MASK_CSSON) | (static_cast<uint32_t>(val) << OFFSET_CSSON);
    }

    // PLLON ----------------------

    enum class PLLON {
      PLL_OFF = 0x00,
      PLL_ON  = 0x01
    };

    PLLON readPLLON() const {
      return static_cast<PLLON>((reg_ & MASK_PLLON) >> OFFSET_PLLON);
    }

    void writePLLON(PLLON val) {
      reg_ = (reg_ & ~MASK_PLLON) | (static_cast<uint32_t>(val) << OFFSET_PLLON);
    }

    // PLLRDY ---------------------

    enum class PLLRDY {
      PLL_NOT_READY = 0x00,
      PLL_READY  = 0x01
    };

    PLLRDY readPLLRDY() const {
      return static_cast<PLLRDY>((reg_ & MASK_PLLRDY) >> OFFSET_PLLRDY);
    }

    // PLLI2SON --------------------

    enum class PLLI2SON {
      PLLI2S_OFF = 0x00,
      PLLI2S_ON  = 0x01
    };

    PLLI2SON readPLLI2SON() const {
      return static_cast<PLLI2SON>((reg_ & MASK_PLLI2SON) >> OFFSET_PLLI2SON);
    }

    void writePLLI2SON(PLLI2SON val) {
      reg_ = (reg_ & ~MASK_PLLI2SON) | (static_cast<uint32_t>(val) << OFFSET_PLLI2SON);
    }

    // PLLI2SRDY --------------------

    enum class PLLI2SRDY {
      PLLI2S_NOT_READY = 0x00,
      PLLI2S_READY  = 0x01
    };

    PLLI2SRDY readPLLI2SRDY() const {
      return static_cast<PLLI2SRDY>((reg_ & MASK_PLLI2SRDY) >> OFFSET_PLLI2SRDY);
    }

  private:
    volatile uint32_t reg_;
  }; // class CR

  CR cr;
}; // class RCC

} // namespace STM32F4xx

static_assert(std::is_pod<::STM32F4xx::RCC::CR>::value, "CR is not a POD");
static_assert(sizeof(::STM32F4xx::RCC::CR) == ::STM32F4xx::RCC::CR::REGISTER_SIZE, "CR is not the correct size of a register");

// Example of overlaying safe register class over peripheral memory.
STM32F4xx::RCC& rcc = *reinterpret_cast<STM32F4xx::RCC*>(STM32F4xx::RCC::PERIPHERAL_BASE_ADDRESS);

// End Autogenerated Code =============================




using namespace STM32F4xx;

int main() {

  //STM32F4xx::RCC rcc;

  // Example usage
  rcc.cr.writeHSION(RCC::CR::HSION::HSI_ON);
  rcc.cr.writeHSITRIM(0x18);
  rcc.cr.writePLLON(RCC::CR::PLLON::PLL_ON);

  // Wait for HSI oscillator to start up
  while(rcc.cr.readHSIRDY() != RCC::CR::HSIRDY::HSI_READY);

  std::cout << rcc.cr.read() << std::endl;

  return 0;
}
